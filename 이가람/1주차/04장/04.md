# 1주차

## 목차
1. 사용자 및 권한
2. 아키텍처

## 1. 사용자 및 권한
- mysql 8.0 부터 ID 접근 시 ip에 따른 제어 가능
- role 추가
    - 롤 그룹을 생성하고 롤 그룹에 따른 롤을 부여해서 적용 가능

## 2. 아키텍처
### MySQL의 전체 구조
- **엔진**
- **커넥션 핸들러**: 접속 및 쿼리 요청
- **SQL 파서**
- **전처리기**
- **옵티마이저**: 쿼리 최적화 실행
- **스토리지 엔진**: SQL 문장 분석, 최적화, 실제 데이터를 디스크 스토리지에 저장 및 읽기
- **InnoDB**
    - 핸들러 API
    - 스토리지 엔진에 쓰기 또는 읽기 요청
- **스레딩 구조**
    - **MySQL 서버는 프로세스 기반이 아니라 스레드 기반으로 작동한다.**
        - **포그라운드**
            - **클라이언트 스레드**: 사용자 요청 쿼리 처리
        - **백그라운드 (InnoDB)**
            - 인서트 버퍼를 병합 스레드
            - 로그 → 디스크 기록 스레드
            - 버퍼풀 → 디스크 기록 스레드
            - 데이터를 버퍼로 읽어 오는 스레드
### 잠금, 데드락 모니터링 스레드
- **InnoDB 테이블은 데이터 버퍼나 캐시까지만 포그라운드 스레드가 처리, 나머지 버퍼로부터 디스크까지는 기록하는 작업은 백그라운드 스레드**

### 메모리 할당 및 사용구조
- **단순하게 운영체제로부터 메모리를 할당 받는다고 생각해도 된다.**
- **글로벌 메모리 영역**
    - 클라이언트 스레드의 수와 무관하게 하나의 메모리 공간만 할당
- **로컬 메모리 영역(특징: 절대 공유되지 않음)**
    - 세션 메모리 영역 → 클라이언트 스레드가 쿼리를 처리하는 메모리 영역
    - 정렬 버퍼
    - 조인버퍼
    - 바이너리 로그캐시
    - 네트워크 버퍼

### 플러그인 스토리지 엔진 모델
- **스토리지엔진 이외에 부가적인 기능을 더 제공하는 플러그인 모델이다.**

### 컴포넌트
- **8.0버전부터 컴포넌트 아키텍처 지원**
    - 예: 비밀번호 검증 기능 컴포넌트를 설치하여 비밀번호 검증을 빠르게 진행 가능

### 쿼리 실행 구조
- **쿼리파서**
    - 사용자 요청으로 들어온 쿼리 문장을 토큰으로 분리해 트리 형태의 구조로 만들어내는 작업
- **전처리기**
    - 권한, 문법을 체크한다
- **옵티마이저**
    - 쿼리 문장을 저렴한 비용으로 가장 빠르게 처리할지 결정
- **실행엔진**
    - 핸들러를 실행하는 관리자 역할을 진행한다
    - **핸들러** → 작업자
        - MySQL 가장 밑당에서 데이터 → 디스크 저장, 디스크 읽어오는 역할

### 스레드 풀
- **스레드풀은 사용자 요청을 처리하는 스레드 개수를 줄여서 동시 처리되는 요청이 많다 하더라도 MySQL 서버의 CPU가 제한된 개수의 스레드 처리에만 집중할 수 있게 해서 서버의 자원 소모를 줄이는 것이 목적**

### 트랜잭션 지원 메타데이터
- **데이터베이스 서버에서 테이블의 구조 정보와 스토어드 프로그램 등의 정보를 데이터 딕셔너리 또는 메타데이터라고 한다.**
- **InnoDB에 저장된다.**

### InnoDB 스토리지 엔진 아키텍처
- **프라이머리 키에 의한 클러스터링**
    - InnoDB의 모든 테이블은 기본적으로 프라이머리 키를 기준으로 클러스터링되어 저장된다.
    - 키 값의
  - **키 값의 순서대로 디스크에 저장**: 스캔이 빠르다
- **외래 키 지원**
    - 스토리지 엔진 레벨에서 지원하는 기능
    - `foreign_key_checks` 시스템 변수를 잠시 OFF하여 기능 제어 가능
    - 단, 다시 활성화 할 때 컬럼 값 확인 필요

### MVCC (Multi Version Concurrency Control)
- **레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 기능**
- **잠금을 사용하지 않은 일관된 읽기 제공**
- 롤백이나 커밋이 되지 않은 상태에서 다른 사용자가 같은 쿼리로 작업 중인 레코드를 조회하면 어떻게 될까?
    - 격리 수준에 따라 다르다.
### 잠금 없는 일관된 읽기(Non-Locking Consistent Read)

InnoDB 스토리지 엔진은 MVCC 기술을 사용해 잠금을 걸지 않고 일기 작업을 수행하기 때문에 읽기 작업은 다른 트랜잭션이 가지고 있는 잠금을 기다리지 않고 바로 가능하다.

이러한 특징 때문에 UPDATE인 상태의 레코드를 다른 사용자가 SELECT 하더라도 이 UPDATE 트랜잭션이 SELECT 작업을 방해하지 않는다. 이를 잠금 없는 일관된 읽기라고 한다.

### 자동 데드락 감지

InnoDB 스토리지 엔진은 내무적으로 잠금이 교착 상태에 빠지지 않았는지 체크하기 위해 잠금 대기 목록을 그래프 형태로 관리한다.

InnoDB 스토리지 엔진은 데드락 감지 스레드를 가져 주기적으로 잠금 대기 그래프를 검사해 교착 상태의 트랜잭션들 중 하나를 강제 종료한다. 이때 기준은 트랜잭션 언두 로그 양이 적은 것 먼저 롤백된다.

동시 처리 스레드가 매우 많을 경우 데드락 감지 스레드는 더 많은 CPU 자원을 소모할 수도 있다.

### 자동화된 장애 복구

InnoDB에는 손실이나 장애로부터 데이터를 보호하기 위해 MySQL 서버가 시작될 때 완료되지 못한 트랜잭션이나 디스크에 일부만 기록된 데이터에 대한 복구 작업이 자동으로 진행된다.

자동 복구 작업이 불가능할 경우 MySQL 서버 설정 파일에 `innodb_force_recovery`를 설정해 MySQL 서버를 시작해야 한다.

### InnoDB 버퍼 풀

InnoDB 스토리지 엔진에서 가장 핵심적인 부분으로, 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간이다.

쓰기 작업을 지연시켜 일괄 작업을 처리할 수 있게 해주는 버퍼 역할도 한다.

InnoDB 버퍼 풀의 크기를 적절히 작은 값으로 설정해 조금씩 증가시키는 방법을 사용하는 것이 좋다.

### Double Write Buffer

InnoDB 스토리지 엔진의 리두 로그는 공간의 낭비를 막기 위해 변경된 내용만 기록하기 때문에 문제 발생시, 내용은 복구가 불가능할 수도 있다. → Partial-page라 한다.

이를 Double - Write로 해결한다

### 언두 로그

InnoDB 스토리지 엔진은 트랜잭션과 격리 수준을 보장하기 위해 DML로 변경되기 전 버전의 데이터를 별도로 백업한다. 이 백업된 데이터를 언두 로그라고 한다.

언두 로그는 백업해둔 이전의 데이터를 활용해 트랜잭션 롤백 시 데이터 복구를 하고, 변경중인 데이터에 다른 커넥션이 접근해 데이터를 조회할 경우 격리 수준에 맞게 변경중인 데이터가 아닌 백업 데이터를 읽어 반환한다.

### 체인지 버퍼

RDBMS의 레코드 변화시에는 데이터 파일을 변경할 뿐만 아니라 해당 테이블의 인덱스 또한 업데이트 해야 한다. 이때, 디스크를 읽는 작업이 필요하기 때문에 많은 자원을 소모할 수도 있다.

InnoDB는 변경해야 할 인덱스가 버퍼 풀에 있으면 바로 업데이트를 하지만 디스크로부터 읽어와야 할 경우 임시 공간에 둔다 이 공간을 체인지 버퍼라고 한다.

### 리두로그 및 로그 버퍼

리두 로그는 영속성과 가장 밀접하게 연관되어 있다.

대부분의 데이터베이스 서버는 데이터 변경 내용을 로그로 먼저 기록 → 쓰기 보다 읽기 성능을 고려(일반적으로 읽기보다 쓰기가 상대적으로 큰 비용 필요)

데이터베이스 서버는 쓰기 비용이 낮은 자료구조를 가진 리두 로그를 갖고 있으며 비정상 종료 시 리두 로그의 데이터를 사용해 복구한다.

데이터를 복구하거나 대용량 데이터를 한번에 적재하는 경우 리두 로그를 비활성화 해 데이터 적재 시간을 단축시킬 수도 있다.

```
mysql> ALTER INSTANCE DISABLE INNODB REDO_LOG;
```

데이터 적재 완료 후 반드시 리두 로그를 활성하 하자!

### 어댑티브 해시 인덱스

사용자가 수동으로 생성하는 인덱스가 아니라 InnoDB 스토리지 엔진에서 사용자가 자주 요청하는 데이터에 대해 자동으로 생성하는 인덱스이다.

어댑티브 해시 인덱스는 B-Tree의 검색 시간을 줄여주기 위한 기능이다.

어댑티브 해시 인덱스가 도움이 되는 경우

- 디스크 읽기가 많은 경우
- 특정 패턴의 쿼리가 많은 경우(조인, LIKE 패턴검색)
- 매우 큰 데이터를 가진 테이블 레코드를 폭넓게 읽는 경우

성능 향상에 도움이 많은 경우

- 디스크의 데이터가 InnoDB 버퍼 풀 크기와 비슷한 경우(디스크 읽기가 적음)
- 동등 조건 검색이 많은 경우
- 쿼리가 데이터 중에서 일부 데이터에만 집중된 경우

### MySQL 로그 파일

로그 파일을 이용하면 MySQL 서버의 깊은 내부 지식이 없이도 MySQL의 상태나 부하를 일으키는 원인을 쉽게 찾아 해결할 수 있다.

### 에러 로그 파일

MySQL이 실행되는 도중에 발생하는 에러나 경고 메시지가 출력되는 로그 파일.

위치는 MySQL 설정 파일(`my.cnf`)에서 `log_error`라는 파라미터 경로에 생성

### 제너럴 쿼리 로그 파일

쿼리 로그 파일의 경로는 `general_log_file`이란 파라미터에 설정돼 있다.

이 로그 파일을 검토해 MySQL 서버에서 실행되는 쿼리에는 어떤 것들이 있는지 검토할 수 있다.

### 슬로우 쿼리 로그

MySQL 서버의 쿼리  중 정기적인 점검을 위한 튜닝에서 어떤 쿼리가 문제의 쿼리인지 판단하기는 어려운데, 이때 슬로우 쿼리 로그가 도움이 된다.

`long_query_time` 시스템 변수에 설정된 시간 이상이 소요된 쿼리가 모두 기록된다. 즉, 슬로우 쿼리 로그 파일에 기록된 쿼리는 `long_query_time` 보다 시간이 오래 걸린 정상적인 쿼리이다.